% everything you need to know to appreciate the solution (relevant parts of literature that the reader must know beforehand)

\subsection{The Coq Proof Assistant}
%Brief intro leading to how classic coq is only discrete and not able to hande probabilites 


When talking about Coq in this report we will be referring to the Coq Proof Assistant, which is a theorem proving system written in the oCaml language and named after both one of its creators, Thierry Coquand, and the abbreviation of "Calculus of Construction", also created by Coquand, and the original basis for the prover\footnote{\textcite{CoqIntro}}. In the context of this course, Coq has mainly been used to construct and prove various structures or operations like binary trees or list permutations. At it's base, Coq is able to handle numbers belonging to either the sets of natural numbers, integers or rationals, as well as several other types like lists or maps. This proves a challenge if you want to work with probabilities, as you cannot be guaranteed that the probability of some event will be strictly a rational number. However, since Coq also provides you with the ability to write and check formal proofs without relying on pen and paper, it can be worth it to extend the language to actually support the types necessary for your area of interest. 
In the case of probabilities, this means access to real numbers and the various rules that govern them, which is fortunately possible with a combination of existing libraries. One way of working with and proving programs in Coq is through the use of Hoare logic, which can be added through the implementation of a small, imperative language called Imp. Both of these aspects will be described further in the following sections \ref{backgroundImp} and \ref{backgroundHoare} 



\subsection{The Imp language}\label{backgroundImp}
%The Imp-chapter (without our alterations)
%The Imp Language is a simple, imperative programming language developed by Edgar T. Irons in the 1960s-1970s.\footnote{\textcite{ImpWiki}}. 
%Imp, being an imperative language, has syntax and semantics describing how to validly state a command that changes the state of the program. Furthermore, Imp is syntax-extendable, thus allowing programmers to extend the language to their need\footnote{\textcite{ImperativeWiki}}.

Supporting a Hoare logic in Coq can be done by first implementing a small, imperative language, with syntax and semantics describing how to validly state a command, that can change the state of a program. 
An example of such a language is found in \textit{Software Foundations 1: Logical Foundations}\footnote{\textcite{SF1}}, where it is simply referred to as Imp.

The basic Imp syntax uses grammar for evaluating both arithmetic and boolean expressions as well as commands like \texttt{Assign} ($x:= a$) and composition of said commands through the use of e.g. sequences of if/else statements. 
The basic Imp syntax and grammar looks as follows\footnote{\textcite{JesperLecImp}}:
\\ \\
$n ::=$ natural numbers
\\
$x ::=$ variables
\\
$a ::=$ $n$ $|$ $x$ $|$ $a_{1} + a_{2}$ $|$ $a_{1} - a_{2}$ $|$ $a_{1} * a_{2}$
\\
$b ::=$ \textbf{true} $|$ \textbf{false} $|$ $a_{1} = a_{2}$ $|$ $a_{1} \leq a_{2}$ $|$ $\neg b$ $|$ $b_{1} \wedge b_{2}$
\\
$c ::=$ $x := a$ $|$ \textbf{skip} $|$ $c_{1};c_{2}$ $|$ \textbf{if} $b$ \textbf{then} $c_{1}$ \textbf{else} $c_{2}$ $|$ \textbf{while} $b$ \textbf{do} $c$
\\
\\
where $x:=a$ means assigning the variable $x$ to the value of $a$, $c_1;c_2$ is the sequence of first applying $c_1$ and then $c_2$ and the remaining notation should be self-explanatory. 

The general idea being that $c$ is the grammar for the commands that changes the state, thus a program in Imp will be written by these commands, for example using the sequential composition ($c_{1};c_{2}$) to chain the commands $x:= 1$ and $y:= 2$, such that the program ends in a state, where these variables are assigned.

Note that the \texttt{while} command is not implemented for this project, as Coq, as a consistent logic, will only allow functions that always terminate, which \texttt{while} statements and loops in general cannot guarantee. The book solves this by treating the evaluation of expressions as a relation instead of as a function\footnote{\textcite{SF1}, Imp.v file} which is not possible for our approach. Fortunately, the \texttt{while} command is not necessary to implement the Hoare logic.

%Maybe a bit more explanation of the arith and bool syntaxes and how the language is used in general. Also how one would extend it.
%Big-step, small-step semantics? Is that relevant?

\subsection{Hoare Logic} \label{backgroundHoare}
%The Hoare triplets, 
The Floyd-Hoare logic originally proposed in 1969, and most commonly referred to as Hoare logic, describes a formal way of working with proving the correctness of computer programs, and holds at it's heart what is known as the Hoare triplet. Notation might wary, but the basis is a triplet comprising a precondition $P$, postcondition $Q$ and some program $c$ of the general form of $\{\{P\}\}\ c\ \{\{Q\}\}$. Such a combination only complies with the definition af a Hoare triplet, if, for some specific state, it is true that the precondition holds before the application of the command(s) making up the program, after which point the postcondition is true.

A simple example could be the following Hoare triplet, which has conditions for the variables $x$ and $y$ before and after assigning $y$ to a new value; $\{\{x=42\}\}\ y:= x\cdot2\ \{\{y=84\}\}$. This example corresponds to the evaluation of the \texttt{Assign}-command in the Imp language, and most of the other commands can be similarly expressed as Hoare rules. 
Another example is the \texttt{Sequence}-command expressed as $c_1 ; c_2$ where $c_1$ and $c_2$ are two separate commands computed on the state one after the other. Besides wrapping this small program in a Hoare triplet, it is possible to make a universal claim about it, a rule, which must hold true for any such triplet. In this case, the rule for sequential composition is, that the pre- and postconditions of the two separate commands must share overlap such that the resulting predicates of them being combined can be found almost transitively. This rule can be expressed using proof tree notation 

\[
\begin{prooftree}
\hypo{ \{\{P\}\} c_1 \{\{Q\}\}}
\hypo{ \{\{Q\}\} c_2 \{\{R\}\} }
\infer2[Sequence]{ \{\{P\}\} c_1;c_2 \{\{R\}\} }
\end{prooftree}
\]

Even though there are countless possibilities for combining commands to form complex programs to be proven, this system is still not able to take probabilities into account.

%and neither is the existing implementation found in Software.%
%Yeeted sentence^ as we haven't (to my knowlegde) mentioned the implementations yet - this is strictly theoretical.


\subsection{Probability and the case of flipping two coins}\label{backgroundCoins}
So many things in life rely on chance, that it is extremely useful to be able to express and compute some outcome even after introducing an element of uncertainty.
Problems in probability often make use of simple systems with real life correspondents, that are easy to visualise and understand, while also representing what can be expanded to more complex and interesting cases. Starting with the basics therefore seems like a solid approach, and in this case means narrowing in on the specific case of flipping two fair coins, and not only try to express it as a program but also prove attributes of it's result. Instead of working with the classic combinations of "heads" and "tails", we imagine two fair coins with the numbers 1 and 2 printed on either side, so they operate as two-sided dice. Flipping the two coins can therefore result in any of the outcomes shown in table \ref{tab:twoCoins}



\begin{table}[H]
\centering
\begin{tabular}{ll|ll}

                        & \multicolumn{3}{l}{Coin x} \\ 
\multirow{3}{*}{Coin y} &         & 1       & 2      \\ \hline
                        & 1       & 2       & 3      \\ 
                        & 2       & 3       & 4
                        
               
\end{tabular}
\caption{Table showing the possible sums of two fair coins $x$ and $y$ that can be flipped to either a value of $1$ or $2$.}
\label{tab:twoCoins}  
\end{table}

From the table it is obvious to see, that the probability of the sum ending up being $3$ is $\frac{2}{4} = \frac{1}{2}$, but it is also not hard to imagine how quickly such a swift judgement would become hard to make, if you either increased the number of variables, their possible outcomes or the number of operations they have to go through. In such cases it would be beneficial to be able to prove that the outcome of such a situation is indeed what we expect it to be, which is exactly made possible, if you successfully add probabilistic Hoare logic to Coq.   

