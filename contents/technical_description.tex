\subsection{Getting Coq ready for probabilities with the infotheo library}
Since Coq is only able to handle numbers that are either naturals, integers or rationals without external libraries, you will need to extend the language in order to work with e.g. the real numbers required when working with probabilities. Coq provides the Reals library, which makes it possible to work with real numbers, but might not be the best type for our problem area. When dealing with probabilities, the chance of some outcome expressed numerically must lie in the range of $[0..1]$. It is possible to prove this attribute in conjunction with any uses, but alternatively you can also make use of a datatype, that is defined as only existing within this range. 
In this project we have been introduced to, and tried working with, the \textit{infotheo}\footnote{\textcite{infotheo}} library, which is released and maintained by Reynald Affeldt et al. and aims to provide, in their own words, "a Coq formalization of information theory and linear error correcting codes"\footnote{\textcite{infotheo}}. To support this work, the developers have also released many extension files describing, for example, different concepts within probabilities as well as the extension \texttt{Reals\_ext.v}, which adds even more lemmas and definitions to the existing Coq library for real numbers. One of these added definitions is the type \texttt{prob}, which is exactly the type of probabilities and takes the form of any real number $p$ for which it is true, that $0\leq p \leq 1$.\\ 

In addition to this type, we have also made great use of various definitions from the \texttt{FSDist.v} file. This includes the \texttt{FSDist1} type, defined as a point-supported distribution, which can be used to describe a function, that only goes to a non-zero value for a single input in its domain. Including these distributions in our program made it possible to not just make statements about single states, but instead distributions over possibly multiple states. 

\subsection{Modifications to the Imp language} \label{meatImp}
The first step to handle probabilities and distributions in Coq was to extend the Imp language already implemented by Benjamin C. Pierce et al. in \textit{Software Foundations 1: Logical Foundations}\footnote{\textcite{SF1}}. 
The Coq implementation included the basic syntax as discussed in Section \ref{backgroundImp}, as well as evaluation functions for the arithmetic, boolean and command grammar. 
% The copy/paste from book part
This last part was lifted directly from the chapter \textit{Simple imperative programs} in \textit{Software Foundations 1: Logical Foundations} with little direct modification and only the implicit consequences from having to modify the type of states these functions work with. For this change we used \textit{infotheo}, specifically the probability library.

The original evaluation functions were based on a simple state of Coq type \texttt{total\_map nat}, which cannot handle the finite types required to make a distribution over state with the \textit{infotheo} library. The type of the state was therefore changed to \texttt{\{ffun var $\rightarrow$ nat\}}, the \texttt{ffun} denoting that the function is a finite type.
Besides the evaluation statements, several definitions and supporting lemmas were also included, which required new proofs to be written for the lemmas based on the new, finite \texttt{state}-type. Some proofs were provided by Alessandro Bruni, while the remaining lemmas remain unproven due to time constraints. 
% Ceval-part 
A simple change was adding a new command to the syntax in order to represent the probabilistic choice, denoted \texttt{CPlus}, of two commands in a state, such that if $c_{1}$ happens with probability $p$, then $c_{2}$ happens with probability $1-p$. This resulted in the following grammar: 
\\
$c ::=$ $x := a$ $|$ \textbf{skip} $|$ $c_{1};c_{2}$ $|$ \textbf{if} $b$ \textbf{then} $c_{1}$ \textbf{else} $c_{2}$ $|$ $c_{1}$ [$+p$] $c_{2}$
\\
\\
The most extensive change was made to the command evaluation function \texttt{ceval}, which was to be altered to return a distribution over states instead of a single state. This change was implemented both through the general update of the \texttt{state}-type as well as by changing the return type of the \texttt{ceval} function to a distribution, by applying \texttt{FSDist1.d} to the resulting states. 
An evaluation for the probabilistic choice operator had to be created from scratch, as it is a new addition, while the other evaluations were only adapted to use \texttt{FSDist1.d}.

An assisting function, \texttt{sample}, has also been made, which assigns the variable $x$ to the probabilistic choice of a fixed sample size. The probability is equally distributed between the contents of the sample. For a sample size of three, the first element would happen with probability $\frac{1}{3} * 1 = \frac{1}{3}$, the second with probability $\frac{1}{2} * \frac{2}{3} = \frac{1}{3}$ and the final element $1 * \frac{1}{3}= \frac{1}{3}$.
A sample of size $1$ would be the same as simply assigning \texttt{x} to that single element. 

%The definitions and lemmas \texttt{t\_empty}, \texttt{t\_update} and \texttt{t\_apply\_empty} \textit{Software Foundations 1: Logical Foundations}\footnote{\textcite{SF1}} are left \texttt{Admitted} and unproven. 

\subsection{Probabilistic Hoare-style logic} \label{meatHoare}
As described in section \ref{backgroundHoare}, the classic Hoare logic is only able to describe situations of the type $\{\{P\}\}\ c\ \{\{Q\}\}$ with a precondition, $P$, postcondition, $Q$, and some command, $c$, that works upon the state on which $P$ and $Q$ are evaluated. In order to take probability into account, this triplet needs to be expanded, which can be done in multiple ways. In this project we have tried two different approaches based on the work of two different sources, each with their own sets of requirements from the program, limitations and challenges. 

\subsubsection{Approach 1: Hoare quadruplet - explicit probability} \label{meatApp1}
\subsubsubsection{Theory} \label{meatApp1Theory}
%Theory of approach 1
The first approach is based on a set of lecture slides from the IMDEA software institute in Madrid\footnote{\textcite{HoareSlides}}. These slides introduce a bounded version of the classic Hoare triplet meant to be implemented with the EasyCrypt platform \footnote{\textcite{easycrypt}}.
The basic idea in this approach is to extend the classic Hoare triplet by including the probability $\delta$, which can be used by the commands to produce distributions of states in the postcondition. This bounded Hoare triplet can be written as $[\{\{P\}\}\; c \;\{\{Q\}\}] \leq \delta$.
Even though $\delta$ is written as an upper bound using $\leq$, it is also possible to express it with $\geq$ or $=$ depending on the intended interpretation of the Hoare triplet.
In all cases $\delta$ must be an actual probability in the range $[0..1]$. All the rules that can be expressed using the classic Hoare triplet should have corresponding versions using this Hoare approach as well. A simple example is the skip command, which does not require much change to be probabilistic, as the command does not change the state in any way. The Hoare triplet can therefore be expressed to hold with full certainty for any postcondition that follows from the precondition.

 \begin{center}
 \begin{prooftree}
    \hypo{\{\{P\}\}\; \Rightarrow \;\{\{Q\}\} \leq \delta_1}
    \hypo{\delta = 1}
    \infer2{[\{\{P\}\}\; \textbf{skip} \; \{\{R\}\}]= \delta} 
 \end{prooftree}
 \end{center}

%A more involved example could be writing the sequence-command, which takes the following form.

% \begin{center}
% \begin{prooftree}
%    \hypo{[\{\{P\}\}\; c_1 \;\{\{Q\}\}] \leq \delta_1}
%    \hypo{[\{\{Q\}\}\; c_2 \;\{\{R\}\}] \leq \delta_2}
%    \hypo{[\{\{P\}\}\; c_1 \;\{\{\neg Q\}\}] \leq \delta_3}
%    \hypo{[\{\{\neg Q\}\}\; c_2 \;\{\{R\}\}] \leq \delta_4}
%    \infer4{[\{\{P\}\}\; c_1;\; c_2\; \{\{R\}\}] = \delta %\geq \delta1\delta2 + \delta_3\delta_4}
% \end{prooftree}
% \end{center}
 
%\begin{center}
%    \begin{prooftree}
%        \hypo{\{\{P\}\}\; c_1 \;\{\{U\}\}}
%        \hypo{\{\{U\}\}\; c_2 \;\{\{Q\}\}}
%        \infer2{\{\{P\}\}\; c_1;\; c_2\; \{\{Q\}\}}
%    \end{prooftree}   
%\end{center}

%where $c_1$ and $c_2$ are commands, $Q$ an intermediate state reached after applying $c_1$ and the remaining symbols represent their usual entities. Comparing this to the classic version found in section \ref{backgroundHoare}, there are both some similarities and differences. The overall shape of the rules are the same and both show the transitivity of applying two commands, that share a condition between them as respectively a post-condition of the first and precondition of the second. The inclusion of the probability $\delta$ necessitates a means of calculating the value based on knowing the probability for each of the four separate outcomes from applying $c_1$ and ending with either $Q$ or $\neg Q$ as post-condition and applying $c_2$ with those two possible outcomes as preconditions as well. %The resulting probability is bounded by  $\delta_1\delta_2+\delta_3\delta_4 \leq \delta$ where the two terms correspond to the combined probabilities of $\chi$ and $\neg \chi$ respectively. 


\subsubsubsection{Implementation} \label{meatApp1Imp}
%Implementation of approach 1
An example of how to encode the classic Hoare triplet can be found in \textit{Software Foundations 2: Programming Language Foundations}\footnote{\textcite{SF2}}, and has been used as a basis for implementing this probabilistic version of a Hoare triplet\footnote{\textcite{HoareSlides}}. While we still need to keep track of both a command and pre- and postcondition, there is also now the fourth parameter of bounding probability, $\delta$, meaning that the Hoare triplet must be expanded into a quadruplet of the form \texttt{hoare\_quad P c Q d} where \texttt{P} and \texttt{Q} are the pre- and postconditions, \texttt{c} some command that is recognised by our Imp language and \texttt{d} the probability that the postcondition holds in this combination. Both \texttt{P} and \texttt{Q} are of the type \texttt{Assertion}, which in this case goes from the finite state of our Imp language to a proposition that can be evaluated to either true or false. Following is the pseudo code for this full implementation

\begin{verbatim}
Theorem: hoare_quad P c Q d := 
                FORALL state THEN
                ASSUME P state THEN
                LET dist' = Evaluate c in state;
                FORALL dist' THEN FORALL state' THEN state' in dist' <-> Q state' THEN
                CONCLUDE Prob dist' s = d. END
\end{verbatim}

The quadruplet is defined to define valid Hoare quadruplets, which is complicated by the types that our Imp language is build upon. The evaluation of some program on a state results in a distribution of possibly many states, from which it must be gleaned what the probability of the postcondition holding is. The probability type \texttt{Pr} from \textit{infotheo} requires, among other things, that we have some event, \texttt{E}, in the form of a set of the finite \texttt{state}-type, which should only contain the states for which the postcondition holds, in order to get the total sum of their probabilities.
The probability \texttt{d} is set as the exact value of the probability, while the theoretical basis has it instead as an upper or lower bound, see section \ref{meatApp1Theory}. To prove the rules relying on \texttt{d} being a bound instead would therefore probably require a total of three definitions of the Hoare quadruplet, one for each type of bound, or otherwise some re-evaluation and possibly limiting of the rules.

Before knowing for certain whether this approach would work out in Coq, we begun formulating several Hoare rules that were intended to be proven, in an effort to have the necessary rules for proving the case of flipping two coins. The Hoare rules were taken mainly from the main source of this approach\footnote{\textcite{HoareSlides}} and complemented by rules from the classic approach in \textit{Software Foundations 2: Programming Language Foundations}\footnote{\textcite{SF2}} when possible, or adapted from J.I.Hartogs PhD dissertation \textit{Probabilistic Extensions of Semantical Models}\footnote{\textcite{PHdProbExtensions}} when necessary. An example is the rule for the If/else-command, which has been implemented as shown below

\begin{verbatim}
Theorem CIf_holds :=
    FORALL P Q c1 c2 p b THEN
      ASSUME hoare_quad P/\b c1 Q p THEN
      ASSUME hoare_quad P/\~b c2 Q p THEN 
      CONCLUDE hoare_quad P (CIf b c1 c2) Q p END
\end{verbatim}

This rule would be a good case for expanding our definition of the Hoare quadruplet to have a separate version, where the probability is an upper bound. If such a version was used in this rule, it would be a direct adatption of the version found in the IMDEA lecture slides\footnote{\textcite{HoareSlides}}. With the probability as an exact value, the rule still holds true, but only for much more specific cases, where the same postcondition is applicable to either of the commands with the exact same probability.

%The case of probabilistic choice existed in neither source, and has instead been adapted from J.I.Hartogs PhD dissertation \textit{Probabilistic Extensions of Semantical Models}\footnote{\textcite{PHdProbExtensions}}, which has a different approach to the probabilistic Hoare, but could still serve as inspiration. The theoretical foundation for the implementation can be seen on page \pageref{hoarerule-prob} and a version of the resulting code can be seen below.
%\begin{verbatim}
%Theorem CPlus_holds :=
%    FORALL P Q c1 c2 p THEN
%      ASSUME hoare_quad P c1 Q p THEN
%      ASSUME hoare_quad Q c2 Y (1-p) THEN 
%      CONCLUDE hoare_quad P (AExp.CPlus p c1 c2) Y END
%\end{verbatim}

%This implementation uses the definition of the Hoare quadruplet and relates the resulting Hoare quadruplet of applying the command of probabilistic choice with two valid quadruplets for each of the two commands in the choice. 

This rule should, like all other Coq \texttt{Theorem}s and \texttt{Lemma}s, ideally be proven instead of simply assuming it's veracity, and attempts were made at proving everything included in our code. Unfortunately these proofs did not reach beyond the absolute initial steps before the complexity of the types became a much too time consuming, insurmountable challenge.
The effort came to a complete halt due to the conversion issues, meaning that we did not have the tools to create proofs, where mechanisms to convert between finitely supported distributions and finite distributions, within the proofs, was needed.
We were not able to work around this issue since our solution was too heavily based on the \textit{infotheo} library, which did not properly support the probabilistic operations that we have attempted to make work. The decision to abandon this approach was based on the judgement of Alessandro Bruni, who was also able to confirm with some of the contributors of the \textt{infotheo}-library, that the implementation of this approach would not pan out.

%This effort ultimately came to complete halt because of these conversion issues between the finite supported distributions of program state, to the needed finite distributions of program state. This mean that we did not have the tools to create proofs, where we look into the finitely supported distributions and would have to have mechanisms to convert them to finite distributions within the proofs.
%We were not able to work around this issue since our solution was too heavily based on the \textit{infotheo} library, which did not properly support the probabilistic operations that we have attempted to make work. The decision to abandon this approach was based on the judgement of Alessandro Bruni, who was also able to confirm with some of the contributors of infotheo, that the implementation of this approach would not pan out.

Since this entire approach was found to not be viable, all Hoare rules remain works-in-progress and are \texttt{Admitted} and unproven. see appendix section \ref{admitted}.. 

\subsubsubsection{Two coins}\label{meatApp1Coins}
Working on the original goal of being able to state and prove a probabilistic case had already begun before this entire approach to a probabilistic Hoare logic had to be abandoned and was also at this point decided to be limited to the case of flipping two coins. 

Simply stating the problem requires the use of sequencing, to flip the two coins one after the other, and probabilistic choice, as each coin can result in either "heads" or "tails". In this case "heads" and "tails" are encoded as the numeric values 1 and 2, with probability $\rho = \dfrac{1}{2}$. Since the probability is split evenly between the two values, the problem can be stated using the sample notation introduced in section \ref{meatImp}. The result would be a lemma of the following form 
$$\text{\textbf{Lemma} Two Coins:}\quad [\{\{ True \}\}\qquad x\; \$\!\!\! =\{1, 2\};\; y\; \$\!\!\! =\{1, 2\}\qquad \{\{(x + y = 3) \}\}]= \dfrac{1}{2} $$

% \begin{verbatim}
% Lemma twoCoinsSample : 
%     forall x y,
%     {{True}} x $={1; 2} ; y $={1; 2} {{x + y = 3}} 1/2
% \end{verbatim}

where the variables $x$ and $y$ represent the two coins.

Stating this problem in Coq was rather straightforward when having access to both the relevant commands and the Hoare quadruplet with what seemed like appropriate types: 

\begin{verbatim}
Lemma twoCoinsSample :=
    FORALL x y THEN
        CONCLUDE hoare_quad
            (fun _ -> True)
            x $= {1, 2}; y $= {1, 2}
            (fun dst -> Prob dst [dst | dst.x + dst.y = 3] = 0.5) END
\end{verbatim}

To prove this Hoare quadruplet also seemed straightforward at first glance, as a lot of useful rules had already been added at this point, even if they were not yet proven. Having formulated the Hoare quadruplet using types from \textit{infotheo} also meant access to possibly useful definitions or lemmas. We did however not have a formal proof of the case within the framework of this approach\footnote{\textcite{HoareSlides}}, and so relied more on Coq in trying to craft a proof.. %The proof however never reached a state beyond the typical, initial steps of \texttt{intro}-ing any conditionals and variables and \texttt{unfold}-ing parts to get access to the inner workings of, for example, the Hoare quadruplet based on its definition. %Although, this seemed promising as the proof would rely on the pre- and post-conditions, that are wrapped within this type.
Though it was possible to state and compile this lemma based on our Imp language and Hoare quadruplet, the problems at the base of the Hoare quadruplet meant that actually proving this or other probabilistic cases could only end in uncertainty.

This lemma and the entire approach to encoding a probabilistic Hoare logic in Coq was therefore abandoned for a second, more promising one, and the lemma is left Admitted and unproven, see appendix section \ref{admitted}. 


\subsubsection{Approach 2: Hoare triplet - implicit probability}\label{meatApp2}
\subsubsubsection{Theory} \label{meatApp2Theory}
%Theory of approach 2
A second approach is presented in J. I. Hartogs PhD dissertation\footnote{\textcite{PHdProbExtensions}} and does not put a bound on the classic Hoare triplet, but instead expands the pre- and postconditions to not just be predicates but instead statements with some probability. This version can be written as $\{\mathbb{P}(p)\}\ c\ \{\mathbb{P}(q)\}$, where $c$ is a command
, $p$ and $q$ are predicates and $P=\mathbb{P}(p)$ and $Q=\mathbb{P}(q)$ the pre- and postconditions where $\mathbb{P}$ indicates the probability of either. In this way, this is similar to the non-probabilistic version in that we are still dealing with a triplet and the classic Hoare triplet can even be thought of as the special case of this second approach with $\mathbb{P}(p) = 1$ and $\mathbb{P}(q)=1$ at all times. 

%Theory, Hoare rules
Some of the simpler Hoare rules like the \texttt{Skip}-, \texttt{Assign}- or \texttt{Sequence}-commands are left mostly unchanged when compared to their classic counterparts. These rules can be written exactly like before but with the addition of the new definition of pre- and postconditions. The more complex rules do however need to take the addition of probability more explicitly into account, like the case of the \texttt{If/else}-command or sequencing, or the probabilistic choice between two different commands which can be written as below 

\begin{center}\label{hoarerule-prob}
    \begin{prooftree}
        \hypo{\{\{ P \}\}\; c_1\; \{\{ Q_{c_1}\}\}}
        \hypo{\{\{ P \}\}\; c_2\; \{\{ Q_{c_2}\}\}}
        \infer2{\{\{ P \}\}\quad c_1 \oplus_\rho c_2\quad \{\{ {Q}_{c_1} \oplus_\rho {Q}_{c_2}\}\}}
    \end{prooftree}   
\end{center}

where $\rho$ is the probability that $c_1$ is chosen and $1-\rho$ the probability that $c_2$ is. 
The dissertation\footnote{\textcite{PHdProbExtensions}} also introduces notation for the probabilistic choice between two predicates, which is used to notate the resulting postcondition of the probabilistic choice as $\{\{Q_{c_1} \oplus_\rho Q_{c_2}\}\}$.
%The dissertation \footnote{\textcite{PHdProbExtensions}} also introduces notation for the probabilistic choice between two predicates, which can be written as $P \oplus_\rho Q$ and is stated to hold for a probabilistic state $\theta$ if there exists some other states $\theta_1$ and $\theta_2$ for which $p$ and $p'$ respectively are satisfied and $\theta_1 \oplus_\rho \theta_2 = \theta$. This is used to notate the resulting post-condition of the probabilistic choice as $\{\{Q_{c_1} \oplus_\rho Q_{c_2}\}\}$


With these rules it is possible to formally prove the case of flipping two coins, which is great preparation for mechanising the proof in Coq. The validity of this proof also gives more confidence in this approach actually being useful in proving probabilistic cases after it is implemented in Coq. The proof is fairly straight-forward, and has an overall structure with two branches, one for each coin, that each split further into two subbranches, one for each possible outcome of the given coin. A version of this proof can be seen in figure \ref{fig:two-coins-semantic-proof} as well as in the form of a proof tree, which can be seen it its full size in appendix section \ref{AppendixProoftree}

\begin{wrapfigure}{r}{0.4\textwidth}\centering
    \includegraphics[scale=0.12]{Pictures/two_coins_semantic_proof.png}
    \caption{The paper proof of the two coins problem encoded with Hoare logic and our Imp language}
\end{wrapfigure}

For the paper proof, we start by expressing the sequence of sampling random numbers for variables $x$ and $y$ in the sample space $\{1; 2\}$. Firstly the proof branches into the possible values that variable $x$ can assume. This is done with the assignment rule and the branches can be combined again by expressing the two possible values that $x$ can assume using the \textit{probabilistic choice operator}. The proof continues by sampling for variable $y$, where the program state remembers the possible values that $x$ can assume. The branches for sampling for the $y$ variable gets \textit{merged} in the same fashion and we have similar expressions of probabilistic choice operators. Now the proof branches into four, where we each consider the probability of the sum of $x + y$ equalling their sum. We \textit{merge} these branches once again and conclude that the probability that the sum is computed to three is $\sfrac{1}{2}$.

\subsubsubsection{Implementation} \label{meatApp2Imp}
%Implementation of approach 2
This second approach to a probabilistic Hoare structure can be implemented in Coq based on the implementation of the classic Hoare triplet found in \textit{Software Foundations 2: Programming Language Foundations}\footnote{\textcite{SF2}}. 

\begin{verbatim}
Definition hoare :=
    FORALL dst THEN
        (ASSUME P dst THEN CONCLUDE Q (Bind dst (fun st => ceval st c)) END) = True.
\end{verbatim}

At first glance, the triplet is defined in exactly the same way where \texttt{P} and \texttt{Q} are the pre- and postconditions and \texttt{c} some command recognised by our Imp language. \texttt{P} and \texttt{Q} are also still of the type \texttt{Assertion}, but this is now a type that goes from a distribution over states to a boolean to support that both assertions is true with some probability, that can be different from 1.   

Initially, the definition in Coq checks that all possible distributions hold in the precondition. In the next step it checks whether the postcondition also holds by firstly using a binding on the distribution of states, where the command \texttt{c} is evaluated in each state, lastly returning it all as a finite supported state, containing no distributions of state that has 0 probability of occurring.


%Hoare rules in this approach
In order to prove any program with this version of the Hoare triplet, we once again need some rules for the different commands, recognised by our Imp language, as well as some more general rules. An example is the rule of consequence for three statements with overlapping pre- and postconditions that can be combined to a single result in a transitive manner. The rules that have been implemented in Coq have been done so based on their necessity to the proof of the case of flipping two coins, as outlined in the previous section \ref{meatApp2Theory}. As such, only the rules for assignment, sequences, rule of consequence, probabilistic choice and skip were added to begin with. The rules are implemented directly from their form in the dissertation\footnote{\textcite{PHdProbExtensions}}.

An example is the rule for probabilistic choice seen below

\begin{verbatim}
Axiom HoareProb :=
    FORALL P Q Q' c1 c2 d THEN
        ASSUME hoare P c1 Q THEN
        ASSUME hoare P c2 Q' THEN
        CONCLUDE hoare P c1 [+ d ] c2 (conva Q Q' d) END
\end{verbatim}

A helper function (\texttt{conva}) has been added mainly for the rule of probabilistic choice, which needs more computations to get the resulting postcondition, from the choice between two separate choices of program. This operation states the relationship between two assertions, and the convex combination of the distributions for which they hold true, and the probability of this, which is based on the probabilistic choice between predicates described in section \ref{meatApp2Theory}.

All rules have been \texttt{Admitted} and are unproven, see appendix section \ref{admitted}.

\subsubsubsection{Two coins}\label{meatApp2Coins}

The case of flipping two coins and proving the outcome has been written in the probabilistic Hoare logic, that we have implemented, in the form of the following lemma:
$$\text{\textbf{Lemma} Two Coins:}\quad \{\{ True \}\}\qquad x\; \$\!\!\! =\{1, 2\};\; y\; \$\!\!\! =\{1, 2\}\qquad \{\{\mathbb{P}(x + y = 3) = 3\}\}$$

%The two coin problem is implemented in the Hoare logic that we have defined. The implementation is constructed as a lemma that states: "Given a precondition that holds true, we sample two numbers for variables $x$ and $y$, both from a sample space of $\{1, 2\}$. We then expect that the two randomly sampled numbers sum to $3$ with a probability of $\dfrac{1}{2}$.

The primary problem of this work was in attempting to reason about, and interact with, the postcondition and its distributions of states. Especially accessing the values of \texttt{x} and \texttt{y} was challenging, as we could not figure out how to query these values from within the finite type monad, that the program state was wrapped in. The final push to state the problem in Coq came in a close meeting with our supervisor, who were able to identify a solution which made it possible to use the \texttt{Pr} function from the \textit{math-comp} library, which computes the probability of some event occurring in a distribution

To more easily formulate this in Coq, a new definition was added, which states the equality between the probability \texttt{Pr} over a distribution of states and set of events in the form of evaluated expressions, and a given probability \texttt{p}. This structure is called \texttt{preq} for equality of probabilities and meant that the case of two coins could be expressed as below, where the postcondition in the actual code is written using \texttt{preq}

% Use this mathy expression in the theory section?
% \begin{center}
%     \begin{equation*}
%         \forall x\:y, \{\{\:True\:\}\}\:x\: \$\!\!=\{1, 2\};\:y\:\$\!\!=\{1, 2\}\; \{\{\mathbb{P}(x + y = 3)=\dfrac{1}{2}\}\}
%     \end{equation*}
% \end{center}

\begin{verbatim}
LEMMA two_coins := 
  FORALL x y THEN
    CONCLUDE 
      hoare
        (fun _ -> True)
        x $= {1, 2}; y $= {1, 2}
        (probability (x + y = 3) = 1/2)
    END 
\end{verbatim}


Even though the lemma is both rather short and describes a very simple situation, proving it in Coq took several tries, with a lot of the challenges, and required help .

The final proof follows the same structure as outlined in figures \ref{fig:two-coins-prooftree-main} and \ref{fig:two-coins-semantic-proof} with separate branches for the two coins, \texttt{x} and \texttt{y}, and their two possible outcomes. The two sub-branches of the \texttt{x}-branch required many of the same operations, which made it possible to take advantage of the \texttt{c1 ; c2} - notation in Coq, which applies the command \texttt{c2} to any resulting branch of the command \texttt{c1}. Besides using the implemented Hoare rules for assignments and rule of consequences, a lemma was also added related to how the \texttt{preq}-structure operates in combination with assignment. This lemma was introduced and applied at the final points of the \texttt{x}-branch after it became apparent, that it could not easily be proven in Coq but represents a point, that can easily be argued to be true.

The two sub-branches in the \texttt{y}-branch vary a bit from each other, even though some steps are repeated in identical order in both. Both sub-branches rely on the addition of more small lemmas, that state easily argued points that were therefore not deemed high priority to prove in Coq. Three of these lemmas became quite specific with regards to the situation they can be applied to, but were nonetheless accepted in order to move the larger prove further along. These three lemmas were used to match the conjunction of two \texttt{preq}-structures with a third, which results directly from this implication. Since especially two of these lemmas look very similar, a possible future improvement could be trying to make a single, more general lemma which encompasses all the cases, and which could be proven and applied in their place. 

By using our own Hoare rules and case specific lemmas it was possible to both state and prove the result of flipping two coins, complete with a \texttt{Qed} accepted by Coq, indicating that all goals and sub-goals have been successfully proven. 

% Additionally, we've made a paper proof to support the correctness of this proof in Coq. You can find a larger version in the the appendix at figure \ref{fig:two-coins-semantic-proof}. The proof is also found in the code repository as a plain text file.

%Old
%On the average run of this program, we expect that the assertion will hold true, as the probability for a sum of $3$, returned from the two coins procedure, would happen one time on average for each program execution.

%How was two coins finally implemented, what changes where made to accomodate
%How is the proof begun, the four branches, how far did we get. 

%We were unable to get the mechanics of this lemma to work, so it is left unfinished. Following is a detailed explanation of why that is.

%The primary problem of this work has been found in the attempts to reason about the post-condition and it's distributions of states. We have found ourselves lacking the capabilities of properly reasoning about, and interacting with, these distributions of state. The conversion issues from finite supported distributions to finite distributions was overcome, but the ability to properly access the values for $x$ and $y$ in the distributions of program states is still lacking. This was due to the program state being wrapped in a finite type monad, which we could not figure out how to query for it's contained values. This means that it was not possible to use the \texttt{Pr} function from the \textit{MathComp} library that computes the probability of some event occurring in a distribution.

